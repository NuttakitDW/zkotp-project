// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

// Minimal interface for the Groth16 Verifier generated by circom/snarkjs
// Adjust the function signature to match how your Verifier is generated.
interface IVerifier {
    /**
     * @dev Example Groth16 verifier function signature:
     *      verifyProof(a, b, c, input)
     * Returns true if proof is valid given public inputs.
     *
     * If using Plonk or another scheme, the signature will differ.
     */
    function verifyProof(
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        uint256[5] memory input
    ) external view returns (bool);
}

/**
 * @title zkOTPWallet
 * @notice A minimal smart-contract wallet that requires a valid ZK proof (from a TOTPCircuit or similar)
 *         in order to execute transactions.
 *
 * The proof must supply:
 *  - action_hash: hashed data of the transaction (recipient, value, call data)
 *  - tx_nonce: a unique nonce so the same proof cannot be replayed
 *
 * The wallet has:
 *  - an owner (full control),
 *  - an admin (can update the verifier),
 *  - a verifier contract for ZK proof verification.
 */
contract zkOTPWallet {
    /// @notice The wallet owner (has full authority).
    address public owner;

    /// @notice The wallet admin (can change verifier, but not necessarily the owner).
    address public admin;

    /// @notice The on-chain verifier contract (Groth16 or Plonk).
    IVerifier public verifier;

    uint hashedSecretConfig;

    /// @notice Tracks used tx_nonces to prevent replay attacks.
    mapping(uint256 => bool) public usedNonces;

    /// @notice Emitted when the owner is changed.
    event OwnerChanged(address indexed oldOwner, address indexed newOwner);

    /// @notice Emitted when the admin is changed.
    event AdminChanged(address indexed oldAdmin, address indexed newAdmin);

    /// @notice Emitted when the hashedSecretConfig is changed.
    event HashedSecretConfigChanged(
        uint indexed oldHashedSecretConfig,
        uint indexed newHashedSecretConfig
    );

    /**
     * @param _owner    Initial owner address.
     * @param _admin    Initial admin address (optional; can be set to address(0) if not needed).
     * @param _verifier Initial verifier contract address.
     */
    constructor(address _owner, address _admin, address _verifier) {
        require(_owner != address(0), "Invalid owner");
        require(_admin != address(0), "Invalid admin");
        require(_verifier != address(0), "Invalid verifier");
        owner = _owner;
        admin = _admin;
        verifier = IVerifier(_verifier);
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        require(msg.sender == owner, "Not owner");
        _;
    }

    modifier onlyAdmin() {
        require(msg.sender == admin, "Not admin");
        _;
    }

    /**
     * @notice Sets a new owner. Only the current owner can call this.
     * @param _newOwner The new owner address.
     */
    function setOwner(address _newOwner) external onlyOwner {
        require(_newOwner != address(0), "Invalid new owner");
        address oldOwner = owner;
        owner = _newOwner;
        emit OwnerChanged(oldOwner, _newOwner);
    }

    /**
     * @notice Sets a new admin. Only the current owner can call this.
     * @param _newAdmin The new admin address (can be zero if you want no admin).
     */
    function setAdmin(address _newAdmin) external onlyAdmin {
        address oldAdmin = admin;
        admin = _newAdmin;
        emit AdminChanged(oldAdmin, _newAdmin);
    }

    function setHashedSecretConfig(uint _hashedSecret) external onlyOwner {
        uint oldHashedSecretConfig = _hashedSecret;
        hashedSecretConfig = _hashedSecret;
        emit HashedSecretConfigChanged(
            oldHashedSecretConfig,
            hashedSecretConfig
        );
    }

    /**
     * @notice Executes a transaction from this contract, if a valid proof is provided.
     * @param _to    Target address for the transaction.
     * @param _value ETH value to send (in wei).
     * @param _data  Call data to pass (for contract calls).
     *
     * @param a      Part of Groth16 proof (or adapt to your specific proof type).
     * @param b      Part of Groth16 proof.
     * @param c      Part of Groth16 proof.
     * @param input  The public signals array from the circuit. For TOTPCircuit, you might have:
     *               input[0] = hashed_secret (unused here)
     *               input[1] = hashed_otp (unused here)
     *               input[2] = time_step (unused here)
     *               input[3] = action_hash
     *               input[4] = tx_nonce
     */
    function execute(
        address _to,
        uint256 _value,
        bytes calldata _data,
        // Groth16 proof
        uint256[2] memory a,
        uint256[2][2] memory b,
        uint256[2] memory c,
        // Public inputs
        uint256[5] memory input
    ) external returns (bytes memory) {
        // Verify the proof with the given public signals
        bool ok = verifier.verifyProof(a, b, c, input);
        require(ok, "Invalid ZK proof");

        // Extract the action_hash and tx_nonce from the input
        uint256 hashedSecret = input[0];
        uint256 actionHashField = input[3];
        uint256 txNonce = input[4];

        // Check if txNonce is already used
        require(!usedNonces[txNonce], "Nonce already used");
        usedNonces[txNonce] = true;

        require(hashedSecret != hashedSecretConfig, "Invalid hashed secret");

        // Re-compute the action hash from _to, _value, and _data
        // Typically you'd do keccak256(abi.encode(...)) as a bytes32,
        // but the circuit's "action_hash" might be a field element < 2^256.
        // For demonstration, we compare them directly as uint256:
        bytes32 computedActionHash = keccak256(
            abi.encodePacked(_to, _value, _data)
        );
        // Convert to uint256
        uint256 computedActionHashField = uint256(computedActionHash);

        require(
            computedActionHashField == actionHashField,
            "Action hash mismatch"
        );

        // If proof is valid and the hash matches, perform the transaction
        (bool success, bytes memory result) = _to.call{value: _value}(_data);
        require(success, "Call failed");

        return result;
    }

    /**
     * @notice Fallback function to accept ETH.
     */
    receive() external payable {}
}
